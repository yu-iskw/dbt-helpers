"""Pytest fixtures for DuckDB integration tests (local and Docker)."""

import contextlib
import os
import shutil
import subprocess  # nosec B404
from pathlib import Path

import pytest
from testcontainers.core.container import DockerContainer
from testcontainers.core.waiting_utils import wait_for_logs


def _docker_available() -> bool:
    """Check if Docker is available and running."""
    try:
        import docker  # pylint: disable=import-outside-toplevel

        client = docker.from_env()
        client.ping()
        return True
    except Exception:  # pylint: disable=broad-exception-caught
        return False


def _run_dbt_local(fixture_path: Path, db_path: Path, tmp_dir: Path) -> Path:
    """Run dbt build locally and return the database path."""
    env = os.environ.copy()
    env["DBT_PROFILES_DIR"] = str(fixture_path)

    # Override profile path to host tmp dir
    with (fixture_path / "profiles.yml").open(encoding="utf-8") as f:
        import yaml  # pylint: disable=import-outside-toplevel

        profile = yaml.safe_load(f)

    profile["default"]["outputs"]["dev"]["path"] = str(db_path)

    tmp_profile_path = tmp_dir / "profiles.yml"
    with tmp_profile_path.open("w", encoding="utf-8") as f:
        yaml.dump(profile, f)

    env["DBT_PROFILES_DIR"] = str(tmp_dir)

    subprocess.run(  # nosec B603, B607
        ["dbt", "build", "--project-dir", str(fixture_path)],
        env=env,
        check=True,
        capture_output=True,
    )

    return db_path


def _run_dbt_docker(fixture_path: Path, db_path: Path, tmp_path_factory) -> Path:
    """Run dbt build in Docker container and extract the database file."""
    integration_dir = Path(__file__).parent
    dockerfile_path = integration_dir / "Dockerfile"

    # Create a temporary directory for the database output
    output_dir = tmp_path_factory.mktemp("dbt_docker_output")
    container_db_path = output_dir / "dev.duckdb"

    # Create a modified profiles.yml that writes to /output
    tmp_profiles_dir = tmp_path_factory.mktemp("dbt_profiles")
    import yaml  # pylint: disable=import-outside-toplevel

    with (fixture_path / "profiles.yml").open(encoding="utf-8") as f:
        profile = yaml.safe_load(f)

    # Update profile to write database to mounted output volume
    profile["default"]["outputs"]["dev"]["path"] = "/output/dev.duckdb"

    tmp_profiles_file = tmp_profiles_dir / "profiles.yml"
    with tmp_profiles_file.open("w", encoding="utf-8") as f:
        yaml.dump(profile, f)

    # Build Docker image from Dockerfile
    # The Dockerfile includes the sample_project, but we'll mount volumes to override
    # and ensure the database is written to our output directory
    container = (
        DockerContainer("python:3.12-slim")
        .with_build_context(str(integration_dir))
        .with_dockerfile(str(dockerfile_path))
        .with_volume_mapping(str(fixture_path), "/workspace")
        .with_volume_mapping(str(tmp_profiles_dir), "/root/.dbt")
        .with_volume_mapping(str(output_dir), "/output")
        .with_env("DBT_PROFILES_DIR", "/root/.dbt")
    )

    # Override entrypoint to use mounted volumes and ensure output
    container = container.with_command(
        [
            "sh",
            "-c",
            "dbt build --project-dir /workspace && "
            "if [ -f /workspace/dev.duckdb ]; then cp /workspace/dev.duckdb /output/dev.duckdb; fi",
        ]
    )

    with container:
        # Wait for dbt build to complete
        with contextlib.suppress(Exception):  # pylint: disable=broad-exception-caught
            wait_for_logs(container, "Completed successfully", timeout=60)

        # Copy database file from container output to final location
        if container_db_path.exists():
            shutil.copy(container_db_path, db_path)
        else:
            # Fallback: try to find DB file in workspace (might be in /workspace or /tmp)
            # This shouldn't happen if profiles.yml is correctly configured
            raise FileNotFoundError(
                f"Database file not found at {container_db_path}. Check that profiles.yml path is correctly configured."
            )

    return db_path


@pytest.fixture(scope="session")
def dbt_duckdb_container(tmp_path_factory):
    """Fixture that provides a DuckDB database path generated by running dbt build.

    Supports both local execution and Docker-based execution based on the
    USE_DOCKER environment variable. Defaults to local execution for speed,
    but Docker provides better isolation and reproducibility.
    """
    fixture_path = Path(__file__).parent / "fixtures" / "sample_project"
    tmp_dir = tmp_path_factory.mktemp("dbt_run")
    db_path = tmp_dir / "dev.duckdb"

    use_docker = os.environ.get("USE_DOCKER", "false").lower() == "true"

    if use_docker:
        if not _docker_available():
            pytest.skip("Docker is not available or not running. Set USE_DOCKER=false to use local execution.")
        db_path = _run_dbt_docker(fixture_path, db_path, tmp_path_factory)
    else:
        db_path = _run_dbt_local(fixture_path, db_path, tmp_dir)

    return db_path

    # Cleanup is handled by tmp_path_factory


@pytest.fixture(scope="session")
def dbt_duckdb_container_docker(tmp_path_factory):
    """Docker-based fixture for DuckDB integration tests.

    This fixture explicitly uses Docker to run dbt build, providing better
    isolation and reproducibility. Use this when you need to ensure the
    test environment matches CI/CD conditions.

    Skips if Docker is not available or not running.
    """
    if not _docker_available():
        pytest.skip("Docker is not available or not running. Skipping Docker-based test.")

    fixture_path = Path(__file__).parent / "fixtures" / "sample_project"
    tmp_dir = tmp_path_factory.mktemp("dbt_docker")
    db_path = tmp_dir / "dev.duckdb"

    db_path = _run_dbt_docker(fixture_path, db_path, tmp_path_factory)

    return db_path

    # Cleanup is handled by tmp_path_factory

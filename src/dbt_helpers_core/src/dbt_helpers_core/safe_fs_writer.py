import datetime
import json
import shutil
from pathlib import Path
from typing import Any

from dbt_helpers_sdk import CreateFile, DeleteFile, PlannedOp, UpdateYamlFile


class JSONLAuditLogger:
    """Logger for recording file operations in JSONL format."""

    def __init__(self, log_path: Path):
        self.log_path = log_path
        self.log_path.parent.mkdir(parents=True, exist_ok=True)

    def log(self, op_kind: str, path: Path, extra: dict[str, Any] | None = None) -> None:
        entry = {
            "timestamp": datetime.datetime.now(datetime.timezone.utc).isoformat(),
            "op_kind": op_kind,
            "path": str(path),
        }
        if extra:
            entry.update(extra)

        with self.log_path.open("a", encoding="utf-8") as f:
            f.write(json.dumps(entry) + "\n")


class SafeFSWriter:
    """Handles atomic file operations and backups."""

    def __init__(self, project_dir: Path, audit_log_path: Path | None = None):
        self.project_dir = project_dir
        self.audit_log_path = audit_log_path or project_dir / ".dbt_helpers" / "audit.jsonl"
        self.backup_dir = project_dir / ".dbt_helpers" / "backups"
        self.logger = JSONLAuditLogger(self.audit_log_path)

    def apply_op(self, op: PlannedOp) -> None:
        if isinstance(op, CreateFile):
            self.create_file(op.path, op.content)
        elif isinstance(op, UpdateYamlFile):
            # UpdateYamlFile content should be generated by YamlStore first
            # This is a bit of a mismatch between the SDK type and how it's used
            # In orchestrator, we'll convert UpdateYamlFile to a temp CreateFile-like operation
            # or we add a 'content' field to UpdateYamlFile in the core if needed.
            pass
        elif isinstance(op, DeleteFile):
            self.delete_file(op.path)

    def create_file(self, path: Path, content: str) -> None:
        """Write file atomically after taking a backup if it exists."""
        full_path = self.project_dir / path if not path.is_absolute() else path

        if full_path.exists():
            self._take_backup(full_path)
            op_kind = "update"
        else:
            op_kind = "create"

        full_path.parent.mkdir(parents=True, exist_ok=True)

        # Atomic write: write to .tmp then rename
        tmp_path = full_path.with_suffix(full_path.suffix + ".tmp")
        try:
            with tmp_path.open("w", encoding="utf-8") as f:
                f.write(content)

            # Atomic replace
            tmp_path.replace(full_path)
            self.logger.log(op_kind, path)
        except Exception as e:
            if tmp_path.exists():
                tmp_path.unlink()
            raise e

    def delete_file(self, path: Path) -> None:
        """Delete file after taking a backup."""
        full_path = self.project_dir / path if not path.is_absolute() else path
        if full_path.exists():
            self._take_backup(full_path)
            full_path.unlink()
            self.logger.log("delete", path)

    def _take_backup(self, full_path: Path) -> None:
        """Store a backup of the file in the backup directory."""
        self.backup_dir.mkdir(parents=True, exist_ok=True)

        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        try:
            rel_path = full_path.relative_to(self.project_dir)
        except ValueError:
            # If path is not relative to project_dir, use absolute path's name
            rel_path = Path(full_path.name)

        backup_path = self.backup_dir / f"{timestamp}_{rel_path.name}.bak"

        shutil.copy2(full_path, backup_path)
        self.logger.log("backup", rel_path, {"backup_path": str(backup_path)})
